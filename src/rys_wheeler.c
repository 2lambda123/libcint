/*
 * Copyright (C) 2020-  Qiming Sun <osirpt.sun@gmail.com>
 *
 * Rys-Wheeler scheme for improved accuracy
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <float.h>
#include <math.h>
#include "cint_const.h"
#include "rys_roots.h"

#ifdef HAVE_QUADMATH_H
#include <quadmath.h>
#endif
#define PIE4    0.785398163397448279
#define PIE2    1.570796326794896619
#define SQRTPIE4        .886226925452758013

void gamma_inc_like(double *f, double t, FINT m);
void fmt_erfc_like(double *f, double t, double lower, FINT m);
int _CINTdiagonalize(int n, double *diag, double *diag_off1, double *eig, double *vec);

// (2*n*(n+.5)-.25) / ((2*n+1.5)*(2*n-.5))
static double JACOBI_ALPHA[] = {
0.33333333333333333,
0.52380952380952380,
0.50649350649350649,
0.50303030303030303,
0.50175438596491228,
0.50114416475972540,
0.50080515297906602,
0.50059737156511350,
0.50046082949308755,
0.50036630036630036,
0.50029815146094215,
0.50024740227610094,
0.50020859407592824,
0.50017825311942959,
0.50015408320493066,
0.50013451708366962,
0.50011845534233593,
0.50010510826150935,
0.50009389671361502,
0.50008438818565400,
0.50007625438462711,
0.50006924248719013,
0.50006315523556902,
0.50005783689994216,
0.50005316321105794,
0.50004903402961655,
0.50004536793394428,
0.50004209817293929,
0.50003916960438699,
0.50003653635367190,
0.50003416000546560,
0.50003200819409768,
0.50003005349522149,
0.50002827254735651,
0.50002664535038635,
0.50002515470141369,
0.50002378573807145,
0.50002252556651799,
0.50002136295663319,
0.50002028809089064,
0.50001929235636840,
0.50001836817163219,
0.50001750884196519,
0.50001670843776106,
0.50001596169193934,
0.50001526391305675,
0.50001461091142865,
0.50001399893608085,
};

// (n*n*(n-.5)*(n-.5)) / ((2*n-.5)**2*(2*n-1.5)*(2*n+.5))
static double JACOBI_BETA[] = {
0.,
0.088888888888888888,
0.065306122448979591,
0.063572790845518118,
0.063066867772750125,
0.062850625014548755,
0.062738320280853362,
0.062672532046733834,
0.062630684468568856,
0.062602416888131173,
0.062582426559912488,
0.062567768998403883,
0.062556702173852791,
0.062548141713215067,
0.062541383866652441,
0.062535955695890349,
0.062531529822708589,
0.062527873784375183,
0.062524818820395803,
0.062522240012650971,
0.062520043292355421,
0.062518156728022413,
0.062516524554840128,
0.062515103001981111,
0.062513857324599019,
0.062512759658762918,
0.062511787448488866,
0.062510922276888776,
0.062510148986980612,
0.062509455012926247,
0.062508829866040129,
0.062508264735943065,
0.062507752178295054,
0.062507285868274110,
0.062506860404442965,
0.062506471151567128,
0.062506114113787438,
0.062505785831627557,
0.062505483297850938,
0.062505203888325082,
0.062504945304910089,
0.062504705528039357,
0.062504482777157142,
0.062504275477559592,
0.062504082232481510,
0.062503901799501381,
0.062503733070517678,
0.062503575054691758,
};

// ((n + .5) * (n + 1)) / ((2 * n + .5 + 1) * (2*n + .5))
static double JACOBI_XS[] = {
0.66666666666666667,
0.34285714285714286,
0.30303030303030303,
0.28717948717948718,
0.27863777089783282,
0.27329192546583851,
0.26962962962962963,
0.26696329254727475,
0.26493506493506494,
0.26334026334026334,
0.26205331820760068,
0.26099290780141844,
0.26010404161664666,
0.25934819897084048,
0.25869759143621766,
0.25813166796773354,
0.25763490241102181,
0.25719534598897734,
0.25680365296803653,
0.25645240835114253,
0.25613565372601517,
0.25584854631507776,
0.25558710951969379,
0.25534804753820034,
0.25512860564406956,
0.25492646352013842,
0.25473965287049399,
0.25456649309860319,
0.25440554059253559,
0.25425554837319543,
0.25411543371632063,
0.25398425196850394,
0.25386117521746849,
0.25374547479810638,
0.25363650685291183,
0.25353370034221098,
0.25343654703260615,
0.25334459309302636,
0.25325743200506009,
0.25317469855385971,
0.25309606371222802,
0.25302123026673925,
0.25294992906328939,
0.25288191577208918,
0.25281696809014298,
0.25275488331370951,
0.25269547622488799,
0.25263857724590709,
};

// 2*n / (2*n + 1) * xs[n]
static double JACOBI_CS[] = {
0.0,
0.22857142857142856,
0.24242424242424244,
0.24615384615384614,
0.24767801857585138,
0.24844720496894409,
0.2488888888888889,
0.24916573971078977,
0.24935064935064935,
0.24948024948024947,
0.24957458876914349,
0.24964539007092199,
0.24969987995198078,
0.2497427101200686,
0.24977698483496879,
0.2498048399687744,
0.24982778415614237,
0.24984690753214942,
0.24986301369863015,
0.2498767055729081,
0.24988844265952699,
0.24989858012170384,
0.2499073959748117,
0.24991511035653649,
0.24992189940643548,
0.2499279054119004,
0.24993324432576769,
0.24993801140590131,
0.24994228549442092,
0.24994613229907349,
0.24994960693408587,
0.2499527559055118,
0.2499556186756613,
0.24995822890559732,
0.24996061544924645,
0.24996280315429252,
0.24996481351161153,
0.24996666518511935,
0.24996837444655281,
0.24996995553419061,
0.24997142095034865,
0.24997278170930865,
0.24997404754489776,
0.24997522708505368,
0.24997632799924249,
0.24997735712344897,
0.24997832056655586,
0.24997922380121332,
};

// .5 * (2*n+3) / (2*(2*n+2.5)*(2*n+.5))
static double JACOBI_RN_PART2[] = {
0.14285714285714285,
0.06493506493506493,
0.04242424242424243,
0.031578947368421054,
0.02517162471395881,
0.020933977455716585,
0.017921146953405017,
0.01566820276497696,
0.01391941391941392,
0.012522361359570662,
0.011380504700643246,
0.010429703796412181,
0.009625668449197862,
0.008936825885978428,
0.008340059187516815,
0.007818052594171997,
0.007357578305654824,
0.006948356807511737,
0.006582278481012658,
0.006252859539423517,
0.005954853898352029,
0.005683971201212581,
0.005436668594563331,
0.005209994683678894,
0.005001471020888497,
0.004809000998094547,
0.004630799023322388,
0.004465334900117509,
0.004311289733284618,
0.004167520666803307,
0.004033032456308815,
0.003906954378794254,
0.003788521345773254,
0.0036770583533173463,
0.003571967600744579,
0.0034727177584320443,
0.0033788349776996893,
0.0032898953215124973,
0.003205518360722256,
0.0031253617316819074,
0.0030491164909444914,
0.0029765031340827116,
0.0029072681704260654,
0.0028411811652035114,
0.0027780321763287235,
0.002717629525729815,
0.0026597978553629924,
0.002604376426365955,
};

// (n+1)*(2*n+3)*(2*n+1)*(n+.5)/(4*(2*n+1.5)*(2*n+.5)**2*(2*n-.5))
static double JACOBI_SN[] = {
0.13333333333333333,
0.08163265306122448,
0.07416825598643781,
0.0709502262443439,
0.06913568751600363,
0.06796651363759114,
0.0671491414786434,
0.06654510224785441,
0.06608032893747179,
0.06571154788790812,
0.06541175849833133,
0.06516323143109666,
0.06495383947141564,
0.06477500471903289,
0.06462048755242003,
0.06448564012966823,
0.06436692889568034,
0.06426161934318457,
0.06416756211824705,
0.0640830443746643,
0.06400668426916581,
0.06393735465835922,
0.06387412698028505,
0.06381622935219483,
0.06376301485193818,
0.06371393720711366,
0.06366853194868301,
0.06362640164746242,
0.06358720423728705,
0.0635506436971408,
0.06351646255426473,
0.06348443580608092,
0.06345436595718736,
0.06342607893980243,
0.06339942073944665,
0.06337425458759004,
0.06335045861313604,
0.0633279238675595,
0.06330655265612413,
0.06328625712122146,
0.06326695803447886,
0.0632485837625995,
0.06323106937846144,
0.06321435589421426,
0.06319838959727361,
0.06318312147345809,
0.06316850670420976,
0.06315450422703073,
};

static void shifted_jacobi_moments(int n, double t, double lower, double *mus)
{
        double t_inv = .5 / t;
        double mu0, mu1, mu2, rn, sn;
        double tt = sqrt(t);
        int i;
        if (lower == 0) {
                mu0 = SQRTPIE4 / tt * erf(tt);
                mu1 = t_inv * (mu0 - exp(-t)) - JACOBI_ALPHA[0] * mu0;
                mus[0] = mu0;
                mus[1] = mu1;
                for (i = 0; i < n - 1; i++) {
                        rn = (i * 2 + 3) * t_inv + JACOBI_RN_PART2[i];
                        mu2 = rn * mu1 + JACOBI_SN[i] * mu0;
                        mus[i+2] = mu2;
                        mu0 = mu1;
                        mu1 = mu2;
                }
        } else {
                double lower2 = lower * lower;
                double e0 = exp(-t) * t_inv;
                double et = exp(-t * lower2) * lower * t_inv;
                double u0 = (lower2 - 1) * et;
                double g0 = 1.;
                double g1 = lower2 - JACOBI_ALPHA[0];
                double g2, u1, z;

                mu0 = SQRTPIE4 / tt * (erfc(lower * tt) - erfc(tt));
                mu1 = t_inv * mu0 - e0 + et - JACOBI_ALPHA[0] * mu0;
                mus[0] = mu0;
                mus[1] = mu1;
                for (i = 1; i < n; i++) {
                        rn = (i * 2 + 1) * t_inv + JACOBI_RN_PART2[i - 1];
                        mu2 = rn * mu1 + JACOBI_SN[i - 1] * mu0 + u0;
                        mus[i+1] = mu2;
                        mu0 = mu1;
                        mu1 = mu2;
                        g2 = (lower2 - JACOBI_ALPHA[i]) * g1 - JACOBI_BETA[i] * g0;
                        z = et * (JACOBI_XS[i] * g1 - g2);
                        u1 = -z - u0 * JACOBI_CS[i];
                        g0 = g1;
                        g1 = g2;
                        u0 = u1;
                }
        }
}

static double t_scaled_laguerre(int n, double t, double x, double *ls)
{
        int i;
        double l0 = 1.;
        double l1 = x - 1.5 / t;
        double l2;
        ls[0] = l0;
        ls[1] = l1;
        for (i = 1; i < n; i++) {
                l2 = (x - (2 * i - .5) / t) * l1 - (i - 1) * (i - .5) / t * t * l0;
                ls[i] = l2;
                l0 = l1;
                l1 = l2;
        }
}

static void laguerre_moments(int n, double t, double lower,
                             double *alpha, double *beta, double *moments)
{
        int i;
        double tt = sqrt(t);
        double t_inv = .5 / t;
        double t2_inv = .5 / (t * t);
        double e0 = exp(-t) * t_inv; 
        double l00 = 0.;
        double l01 = 1.;
        double fac0, fac1, l02;

        alpha[0] = t_inv;
        beta[0] = 0;
        if (lower == 0) {
                moments[0] = SQRTPIE4 / tt * erf(tt);
                moments[1] = -l01 * e0;
                for (i = 1; i < n - 1; i++) {
                        alpha[i] = (i * 4 + 1) * t_inv;
                        beta[i] = i * (i * 2 - 1) * t2_inv;
                        fac0 = (i * 4 - 1) * t_inv;
                        fac1 = (i - 1) * (i * 2 - 1) * t2_inv;
                        l02 = (1. - fac0) * l01 - fac1 * l00;
                        l00 = l01;
                        l01 = l02;
                        moments[i+1] = -l01 * e0;
                }
        } else {
                double lower2 = lower * lower;
                double l10 = 0.;
                double l11 = 1.;
                double l12;
                double et = exp(-t * lower2) * lower * t_inv;
                moments[0] = SQRTPIE4 / tt * (erfc(lower * tt) - erfc(tt));
                moments[1] = l11 * et - l01 * e0;
                for (i = 1; i < n - 1; i++) {
                        alpha[i] = (i * 4 + 1) * t_inv;
                        beta[i] = i * (i * 2 - 1) * t2_inv;
                        fac0 = (i * 4 - 1) * t_inv;
                        fac1 = (i - 1) * (i * 2 - 1) * t2_inv;
                        l12 = (lower2 - fac0) * l11 - fac1 * l10;
                        l10 = l11;
                        l11 = l12;
                        l02 = (1. - fac0) * l01 - fac1 * l00;
                        l00 = l01;
                        l01 = l02;
                        moments[i+1] = l11 * et - l01 * e0;
                }
        }
}

static void wheeler_recursion(int n, double *alpha, double *beta, double *moments,
                              double *a, double *b)
{
        int i, j, nc;
        double a0 = alpha[0] + moments[1] / moments[0];
        double b0 = 0;
        double a1, b1;
        a[0] = a0;
        b[0] = b0;
        double buf[MXRYSROOTS * 2];
        double *s0 = moments;
        double *sm = buf;
        double *sk = buf + n;
        double *swap;
        for (i = 2; i < n; i++) {
                sm[i] = 0.;
        }

        for (i = 1; i < n; i++) {
                nc = 2 * (n - i);
                for (j = 0; j < nc; j++) {
                        sk[j] = (s0[2+j] - (a0 - alpha[i+j]) * s0[1+j]
                                 - b0 * sm[2+j] + beta[i+j] * s0[j]);
                }
                a1 = alpha[i] - s0[1] / s0[0] + sk[1] / sk[0];
                b1 = sk[0] / s0[0];
                a[i] = a1;
                b[i] = b1;
                a0 = a1;
                b0 = b1;
                swap = sm;
                sm = s0;
                s0 = sk;
                sk = swap;
        }
}

double CINTrys_wheeler(int n, double x, double lower,
                       double *roots, double *weights)
{
        int i;
        double a[MXRYSROOTS];
        double b[MXRYSROOTS];
        double c0[MXRYSROOTS*MXRYSROOTS];
        double moments[MXRYSROOTS*2];
        double buf[MXRYSROOTS*4];
        double *alpha, *beta;

        if (x < 20.) {
                alpha = JACOBI_ALPHA;
                beta = JACOBI_BETA;
                shifted_jacobi_moments(n * 2, x, lower, moments);
        } else {
                alpha = buf;
                beta = buf + n * 2;
                laguerre_moments(n * 2, x, lower, alpha, beta, moments);
        }

        double mu0 = moments[0];
        wheeler_recursion(n, alpha, beta, moments, a, b);
        for (i = 1; i < n; i++) {
                b[i] = sqrt(b[i]);
        }

        _CINTdiagonalize(n, a, b+1, roots, c0);

        for (i = 0; i < n; i++) {
                roots[i] = roots[i] / (1 - roots[i]);
                weights[i] = c0[i * n] * c0[i * n] * mu0;
        }
}
